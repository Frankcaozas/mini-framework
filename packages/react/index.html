<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div id="root"></div>
    <script
      type="text/javascript"
      src="https://unpkg.com/babel-standalone@6.26.0/babel.min.js"></script>

    <script type="text/babel">
      function createElement(type, props, ...children) {
        return {
          type,
          props: {
            ...props,
            children: children.map((children2) =>
              typeof children2 === 'object'
                ? children2
                : createTextElement(children2)
            ),
          },
        }
      }
      function createTextElement(text) {
        return {
          type: 'TEXT_ELEMENT',
          props: {
            nodeValue: text,
            children: [],
          },
        }
      }
      const isEvent = (key) => key.startsWith('on')
      const isProperty = key => key !== 'children' && !isEvent(key)
      const isGone = (preProps, nextProps) => (key) => !(key in nextProps)
      const isNew = (preProps, nextProps) => (key) =>
        preProps[key] !== nextProps[key]
      function createDOM(fiber) {
        if (typeof fiber.type === 'string') {
          const dom =
            fiber.type === 'TEXT_ELEMENT'
              ? document.createTextNode('')
              : document.createElement(fiber.type)
          updateDom(dom, {}, fiber.props)
          return dom
        }
        return null
      }
      let nextUnitOfWork = null
      let wipRoot = null
      let deletions = null
      let currentRoot = null
      function commitRoot() {
        deletions.forEach(commitWork)
        console.log(wipRoot)
        if (wipRoot.child) commitWork(wipRoot.child)
        currentRoot = wipRoot

        wipRoot = null
      }
      function commitWork(fiber) {
        if (!fiber) return
        let domParentFiber = fiber.parent
        while (!domParentFiber.dom) domParentFiber = domParentFiber.parent
        const domParent = domParentFiber.dom
        if (fiber.effectTag === 'PLACEMENT' && fiber.dom && domParent)
          domParent.appendChild(fiber.dom)
        if (fiber.effectTag === 'UPDATE' && fiber.dom)
          updateDom(fiber.dom, fiber.alternate.props, fiber.props)
        if (fiber.effectTag === 'DELETION' && fiber.dom && domParent)
          commitDeletion(fiber, domParent)
        commitWork(fiber.child)
        commitWork(fiber.sibling)
      }
      function commitDeletion(fiber, domParent) {
        if (!fiber) return
        if (fiber.dom) domParent.removeChild(fiber.dom)
        else commitDeletion(fiber.child, domParent)
      }
      function updateDom(dom, preProps, nextProps) {
        console.log('updatedom')
        Object.keys(preProps)
          .filter(isProperty)
          .filter(isGone(preProps, nextProps))
          .forEach((key) => (dom[key] = ''))
        Object.keys(preProps)
          .filter(isEvent)
          .filter(
            (key) => !(key in nextProps) || isNew(preProps, nextProps)(key)
          )
          .forEach((name) => {
            const eventType = name.toLowerCase().substring(2)
            dom.removeEventListener(eventType, preProps[name])
          })
        Object.keys(nextProps)
          .filter(isProperty)
          .filter(isNew(preProps, nextProps))
          .forEach((key) => (dom[key] = nextProps[key]))
        Object.keys(nextProps)
          .filter(isEvent)
          .filter(isNew(preProps, nextProps))
          .forEach((name) => {
            const eventType = name.toLowerCase().substring(2)
            console.log(eventType)
            console.log(nextProps[name]);
            dom.addEventListener(eventType, nextProps[name])
          })
      }
      function render(element, container) {
        wipRoot = {
          type: container.tagName,
          dom: container,
          props: {
            children: [element],
          },
          alternate: currentRoot,
        }
        deletions = []
        nextUnitOfWork = wipRoot
      }
      function workloop(deadline) {
        let shouldYield = false
        while (nextUnitOfWork && !shouldYield) {
          nextUnitOfWork = performUnitOfWork(nextUnitOfWork)
          shouldYield = deadline.timeRemaining() < 1
        }
        if (!nextUnitOfWork && wipRoot) commitRoot()
        requestIdleCallback(workloop)
      }
      requestIdleCallback(workloop)
      function performUnitOfWork(fiber) {
        if (fiber.type instanceof Function) updateFuntionComponent(fiber)
        else updateHostComponent(fiber)
        if (fiber.child) return fiber.child
        let nextFiber = fiber
        while (nextFiber) {
          if (nextFiber.sibling) return nextFiber.sibling
          nextFiber = nextFiber.parent
        }
        return null
      }
      function reconcileChildren(wipFiber, elements) {
        let oldFiber = wipFiber.alternate && wipFiber.alternate.child
        let index = 0
        let prevSibling = null
        while (index < elements.length) {
          const element = elements[index]
          const sameType = oldFiber && element && oldFiber.type === element.type
          let newFiber = null
          if (sameType) {
            newFiber = {
              type: oldFiber.type,
              props: element.props,
              dom: oldFiber.dom,
              parent: wipFiber,
              child: null,
              sibling: null,
              alternate: oldFiber,
              effectTag: 'UPDATE',
            }
          }
          if (element && !sameType) {
            newFiber = {
              type: element.type,
              props: element.props,
              dom: null,
              parent: wipFiber,
              child: null,
              sibling: null,
              alternate: null,
              effectTag: 'PLACEMENT',
            }
          }
          if (oldFiber && !sameType) oldFiber.effectTag = 'DELETION'
          if (oldFiber) oldFiber = oldFiber.sibling
          if (index === 0) wipFiber.child = newFiber
          else prevSibling.sibling = newFiber
          prevSibling = newFiber
          index++
        }
      }
      function updateFuntionComponent(fiber) {
        if (fiber.type instanceof Function) {
          const children = [fiber.type(fiber.props)]
          reconcileChildren(fiber, children)
        }
      }
      function updateHostComponent(fiber) {
        if (!fiber.dom) fiber.dom = createDOM(fiber)
        const elements = fiber.props.children
        reconcileChildren(fiber, elements)
      }
      const React = {
        createElement,
        render,
      }

      /** @jsx React.createElement */

      function App(props) {
        return <h1>Hi {props.name}</h1>
      }
      const element = (
        <App
          name="foo"
          onClick={() => {
            console.log('1')
          }}
        />
      )
      const container = document.getElementById('root')
      React.render(element, container)
    </script>
  </body>
</html>
